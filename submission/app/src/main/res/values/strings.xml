<resources>
    <string name="app_name">CahyaSANote</string>
    <string name="icon_sa">icon-sa</string>
    <string name="sa_title">SA Title</string>
    <string name="all_chars">The quick brown fox jumps over the lazy dog The quick brown fox jumps over the lazy dog The quick brown fox jumps over the lazy dog The quick brown fox jumps over the lazy dog</string>
    <string name="diagram_software_architecture">diagram software architecture</string>
    <string name="description">Description</string>
    <string name="usage">Usage</string>
    <string name="shortcoming">Shortcoming</string>
    <string name="icon_description">icon description</string>
    <string name="icon_usage">icon usage</string>
    <string name="icon_shortcoming">icon shortcoming</string>
    <string name="icon_more_explanation">icon more explanation</string>
    <string name="more_explanation">More Explanation</string>
    <string name="some_note_of_sa">Some Note of SA</string>
    <string name="icon_app">icon app</string>
    <string name="thanks">Terima Kasih, Mas/Mbak sudah mereview submission ini</string>
    <string name="nama_cahya">Cahyadesthian R. Widigda</string>
    <string name="email_cahya">rizkiwidigda@gmail.com</string>
    <string name="about">about</string>


    <string-array name="data_sa_name">
        <item>Layered</item>
        <item>Event driven</item>
        <item>Microkernel</item>
        <item>Microservices</item>
        <item>Space Based</item>
        <item>Client Server</item>
        <item>Master Slave</item>
        <item>Pipe Filter</item>
        <item>Broker</item>
        <item>Peer to Peer</item>
        <item>MVC</item>
        <item>Blackboard</item>
        <item>Interpreter</item>
    </string-array>


    <string-array name="data_sa_description">
        <item>This pattern can be used to structure programs that can be decomposed into groups of subtasks, each of which is at a particular level of abstraction. Each layer provides services to the next higher layer. Commonly found 4 layers of a general information system are Presentation layer (also known as UI layer), Application layer (also known as service layer) Business logic layer (also known as domain layer), Data access layer (also known as persistence layer)</item>
        <item>The event driven architectural style consists of two topologies mediator and broker. A mediator is used when multiple steps are needed to be orchestrated within an event bus through a central mediator. On the other hand, a broker is used to chain events together without using a central mediator</item>
        <item>This architecture pattern consists of two types of components  a core system and several plug-in modules. While the core system works on minimal functionality to keep the system operational, the plug in modules are independent components with specialized processing</item>
        <item>Microservices architecture pattern is seen as a viable alternative to monolithic applications and service-oriented architectures. The components are deployed as separate units through an effective, streamlined delivery pipeline. It has some benefits, they are enhanced scalability and a high degree of decoupling within the application</item>
        <item>The concept of tuple space the idea of distributed shared memory is the basis of the name of this architecture. The space-based pattern comprises two primary components a processing unit and a virtualized middleware</item>
        <item>A client server architecture pattern is described as a distributed application structure having two main components  a client and a server. This architecture facilitates the communication between the client and the server, which may or may not be under the same network. A client requests specific resources to be fetched from the server, which might be in the form of data, content, services, files, etc. The server identifies the requests made and responds to the client appropriately by sending over the requested resources</item>
        <item>Imagine a single database receiving multiple similar requests at the same time. Naturally, processing every single request at the same time can complicate and slow down the application process. A solution to this problem is a master slave architecture pattern that functions with the master database launching multiple slave components to process those requests quickly</item>
        <item>A pipe filter architecture pattern processes a stream of data in a unidirectional flow where components are referred to as filters, and pipes are those which connect these filters. The chain of processing data takes place where the pipes transmit data to the filters, and the result of one filter becomes the input for the next filter. The function of this architecture is to break down significant components or processes into independent and multiple components that can be processed simultaneously</item>
        <item>A broker pattern is used for structuring distributed systems with decoupled components. By invoking remote services, components can interact with others in broker architecture patterns. Also, the broker is responsible for all the coordination and communication among the components</item>
        <item>In the peer to peer architectural pattern, individual components are called peers. A peer can act as a client, a server, or both and change its role dynamically over time. As a client, a peer can request service from other peers, and as a server, a peer can provide services to other peers. The significant difference between peer-to-peer and client-server architecture is that each computer on the network has considerable authority and the absence of a centralized server. Its capacity increases as more and more computers join the network</item>
        <item>This pattern, also known as MVC pattern, divides an interactive application in to 3 parts as,Model(contains the core functionality and data),View(displays the information to the user, more than one view may be defined), and Controller (handles the input from the user). This is done to separate internal representations of information from the ways information is presented to, and accepted from, the user. It decouples components and allows efficient code reuse</item>
        <item>This pattern is useful for problems for which no deterministic solution strategies are known. The blackboard pattern consists of 3 main components. Blackboard (a structured global memory containing objects from the solution space), Knowledge source (specialized modules with their own representation), Control component (selects, configures and executes modules.) All the components have access to the blackboard. Components may produce new data objects that are added to the blackboard. Components look for particular kinds of data on the blackboard, and may find these by pattern matching with the existing knowledge source</item>
        <item>This pattern is used for designing a component that interprets programs written in a dedicated language. It mainly specifies how to evaluate lines of programs, known as sentences or expressions written in a particular language. The basic idea is to have a class for each symbol of the language</item>
    </string-array>


    <string-array name="data_sa_usage">
        <item>Applications that are needed to be built quickly, Enterprise applications that require traditional IT departments and processes,Appropriate for teams with inexperienced developers and limited knowledge of architecture patterns, Applications that require strict standards of maintainability and testability.</item>
        <item>For applications where individual data blocks interact with only a few modules, Helps with user interfaces.</item>
        <item>Applications that have a clear segmentation between basic routines and higher-order rules, Applications that have a fixed set of core routines and dynamic set of rule that needs frequent updates</item>
        <item>Businesses and web applications that require rapid development, Websites with small components, data centers with well-defined boundaries, and remote teams globally.</item>
        <item>Applications and software systems that function with a large user base and a constant load of requests, Applications that are supposed to address scalability and concurrency issues.</item>
        <item>Applications like emails, online banking services, the World Wide Web, network printing, file sharing applications, gaming apps, etc, Applications that focus on real-time services like telecommunication apps are built with a distributed application structure, Applications that require controlled access and offer multiple services for a large number of distributed clients, An application with centralized resources and services that has to be distributed over multiple servers.</item>
        <item>Development of Operating Systems that may require a multiprocessors compatible architecture, Advanced applications where larger services have to be decomposed into smaller components, Applications processing raw data stored in different servers over a distributed network, Web browsers that follow multithreading to increase its responsiveness.</item>
        <item>It can be used for applications facilitating a simple, one-way data processing and transformation, Applications using tools like Electronic Data Interchange and External Dynamic List, Development of data compilers used for error-checking and syntax analysis, To perform advanced operations in Operating Systems like UNIX, where the output and input of programs are connected in a sequence.</item>
        <item>Used in message broker softwares such as Apache ActiveMQ, Apache Kafka, RabbitMQ, and JBoss Messaging, For structuring distributed systems that have decoupled components.</item>
        <item>File sharing networks such as Gnutella and G2, Cryptocurrency-based products such as Bitcoin and Blockchain, Multimedia products such as P2PTV and PDTP.</item>
        <item>Architecture for World Wide Web applications in major programming languages, Web frameworks such as Django and Rails.</item>
        <item>Speech recognition, Vehicle identification and tracking, Protein structure identification, Sonar signals interpretation.</item>
        <item>Database query languages such as SQL, Languages used to describe communication protocols</item>
    </string-array>


    <string-array name="data_sa_shortcomings">
        <item>Unorganized source codes and modules with no definite roles can become a problem for the application, Skipping previous layers to create tight coupling can lead to a logical mess full of complex interdependencies, Basic modifications can require a complete redeployment of the application.</item>
        <item>Testing individual modules can only be done if they are independent, otherwise, they need to be tested in a fully functional system, When several modules are handling the same events, error handling becomes challenging to structure, Development of a system-wide data structure for events can become arduous if the events have different needs, Maintaining a transaction-based mechanism for consistency can become complex with decoupled and independent modules</item>
        <item>The plugins must have good handshaking code so that the microkernel is aware of the plugin installation and is ready to work, Changing a microkernel is almost impossible if there are multiple plugins dependent on it, It is difficult to choose the right granularity for the kernel function in advance and more complex at a later stage.</item>
        <item>Designing the right level of granularity for a service component is always a challenge, All applications do not include tasks that can be split into independent units, Performance can be affected because of tasks being spread across different microservices.</item>
        <item>It is a complex task to cache the data for speed without disturbing multiple copies.</item>
        <item>Incompatible server capacity can slow down, causing a performance bottleneck, Servers are usually prone to a single point of failure, Changing the pattern is a complex and expensive process, Server maintenance can be a demanding and expensive task.</item>
        <item>Failure of the master component can lead to a loss of data with no backup over the slave components, Dependencies within the system can lead to a failure of the slave components, There can be an increase in overhead costs due to the isolated nature of the slave components.</item>
        <item>There can be a loss of data in between filters if the infrastructure design is not reliable,The slowest filter limits the performance and efficiency of the entire architecture, During transmission between filters, the data-transformation overhead costs might increase, The continuous transformational character of the architecture makes it less user-friendly for interactional systems.</item>
        <item>Shallow fault tolerance capacity, Requires standardization of service description, The hidden layer may decrease software performance, Higher latency and requires more effort in deployment.</item>
        <item>No guarantee of high-quality service, Achieving robust security is challenging, Performance depends on the number of nodes connected to the network, No way to backup files or folders, Might need a specific interface to read the file.</item>
        <item>The MVC pattern introduces new levels of indirection and thereof increases the complexity of the solution. It also increases the event-driven nature of the user-interface code, which can become more difficult to debug, Developers cannot completely ignore the view of the model even if they are decoupled. If the model undergoes frequent changes, the views could be flooded with update requests, Views like graphical displays may take some time to render, As a result, the view may fall behind update requests.</item>
        <item>The structure change of blackboard may have a significant impact on all of its agents as close dependency exists between blackboard and knowledge source, It can be difficult to decide when to terminate the reasoning as only approximate solution is expected, Problems in synchronization of multiple agents, Major challenges in designing and testing of system.</item>
        <item>Slower, Dependencies file required, and Less Secure</item>
    </string-array>


    <integer-array name="data_sa_icon">
        <item>@drawable/ic_baseline_layers_24</item>
        <item>@drawable/ic_baseline_event_24</item>
        <item>@drawable/ic_baseline_fiber_smart_record_24</item>
        <item>@drawable/ic_baseline_dynamic_feed_24</item>
        <item>@drawable/ic_baseline_space_bar_24</item>
        <item>@drawable/ic_baseline_person_pin_circle_24</item>
        <item>@drawable/ic_baseline_people_alt_24</item>
        <item>@drawable/ic_baseline_filter_alt_24</item>
        <item>@drawable/ic_baseline_alt_route_24</item>
        <item>@drawable/ic_baseline_edit_road_24</item>
        <item>@drawable/ic_baseline_settings_overscan_24</item>
        <item>@drawable/ic_baseline_developer_board_24</item>
        <item>@drawable/ic_baseline_swap_calls_24</item>
    </integer-array>


    <integer-array name="data_sa_diagram">
        <item>@drawable/layerpattern</item>
        <item>@drawable/eventdrivenpattern</item>
        <item>@drawable/microkernelpattern</item>
        <item>@drawable/microservicepattern</item>
        <item>@drawable/spacebasedpattern</item>
        <item>@drawable/clientserverpattern</item>
        <item>@drawable/masterslavepattern</item>
        <item>@drawable/pipefilterpattern</item>
        <item>@drawable/brokerpattern</item>
        <item>@drawable/peertopeerpattern</item>
        <item>@drawable/mvcpattern</item>
        <item>@drawable/blackboardpattern</item>
        <item>@drawable/interpreterpattern</item>
    </integer-array>


    <string-array name="data_sa_explanation">
        <item>As we can see in the diagram above, a standard layered architecture has five parts. Those are first,User interaction layer This is the layer that interacts with users through screens, forms, menus, reports, etc. It is the most visible layer of the application. It defines how the application looks. Second is Functionality layer This is the layer that presents the functions, methods, and procedures of the system based on the business rules layer. It determines how the pull-down menus work, how the buttons work, and how the system navigates through screens. The tird is Business rules layer This layer contains rules that determine the behavior of the whole application, such as, If an invoice is printed, then send an email to the customer, select all items sold, and decrease their stock in the stock management module. Forth is Application core layer This server contains the main programs, code definitions, and basic functions of the application. Programmers work in this layer most of the time.Last is Database layer This layer contains the tables, indexes, and data managed by the application. Searches and insert/delete/update operations are executed here. </item>
        <item>An event-driven architecture uses events to trigger and communicate between decoupled services and is common in modern applications built with microservices. An event is a change in state, or an update, like an item being placed in a shopping cart on an e-commerce website. Events can either carry the state (the item purchased, its price, and a delivery address) or events can be identifiers (a notification that an order was shipped).Event-driven architectures have three key components event producers, event routers, and event consumers. A producer publishes an event to the router, which filters and pushes the events to consumers. Producer services and consumer services are decoupled, which allows them to be scaled, updated, and deployed independently.</item>
        <item>A microkernel architecture is called a plugin architecture because of the way capabilities and functionality are added to a minimal core OS. Theyre an efficient way to achieve application customization and can offer software lifecycle benefits.With a microkernel architecture, there is a core and plugins. The core application is centralized, like a monolith. And most additional development is done through plugins that add capabilities or modify existing functionality. Generally, these plugins do not know about each other and do not communicate with each other. However, the microkernel provides interprocess communication a way for the processes to talk.</item>
        <item>A microservices architecture consists of a collection of small, autonomous services. Each service is selfcontained and should implement a single business capability within a bounded context. A bounded context is a natural division within a business and provides an explicit boundary within which a domain model exists.Microservices architecture (often shortened to microservices) refers to an architectural style for developing applications. Microservices allow a large application to be separated into smaller independent parts, with each part having its own realm of responsibility. To serve a single user request, a microservices-based application can call on many internal microservices to compose its response. Containers are a well-suited microservices architecture example, since they let you focus on developing the services without worrying about the dependencies. Modern cloud-native applications are usually built as microservices using containers.</item>
        <item>A Space-based architecture (SBA) is an approach to distributed computing systems where the various components interact with each other by exchanging tuples or entries via one or more shared spaces. This is contrasted with the more common Message queuing service approaches where the various components interact with each other by exchanging messages via a message broker. In a sense, both approaches exchange messages with some central agent, but how they exchange messages is very distinctive. An analogy might be where a message broker is like an Academic conference, where each presenter has the stage, and presents in the order they are scheduled; whereas a tuple space is like an Unconference, where all participants can write on a common whiteboard concurrently, and all can see it at the same time.A key goal of both approaches is to create loosely-coupled systems that minimize configuration, especially shared knowledge of who does what, leading to the objectives of better availability, resilience, scalability, etc.</item>
        <item>client-server architecture, architecture of a computer network in which many clients (remote processors) request and receive service from a centralized server (host computer). Client computers provide an interface to allow a computer user to request services of the server and to display the results the server returns. Servers wait for requests to arrive from clients and then respond to them. Ideally, a server provides a standardized transparent interface to clients so that clients need not be aware of the specifics of the system (i.e., the hardware and software) that is providing the service. Clients are often situated at workstations or on personal computers, while servers are located elsewhere on the network, usually on more powerful machines. This computing model is especially effective when clients and the server each have distinct tasks that they routinely perform. In hospital data processing, for example, a client computer can be running an application program for entering patient information while the server computer is running another program that manages the database in which the information is permanently stored. Many clients can access the servers information simultaneously, and, at the same time, a client computer can perform other tasks, such as sending e-mail. Because both client and server computers are considered independent devices, the client-server model is completely different from the old mainframe model, in which a centralized mainframe computer performed all the tasks for its associated “dumb” terminals, which merely communicated with the central mainframe.</item>
        <item>The master-slave concept has been around for a while now. This is a fairly simple concept actually, all you need to understand is that there is one master and there are many slaves. Master-slave is a way to optimize the I/O in your application other than using caching. The master database serves as the keeper of information, so to speak. The true data is kept at the master database, thus writing only occurs there. Reading, on the other hand, is only done in the slave. What is this for? This architecture serves the purpose of safeguarding site reliability. If a site receives a lot of traffic and the only available database is one master, it will be overloaded with reading and writing requests. Making the entire system slow for everyone on the site.Master/slave is a model of communication for hardware devices where one device has a unidirectional control over one or more devices. This is often used in the electronic hardware space where one device acts as the controller, whereas the other devices are the ones being controlled. In short, one is the master and the others are slaves to be controlled by the master. The most common example of this is the master/slave configuration of IDE disk drives attached on the same cable, where the master is the primary drive and the slave is the secondary drive.</item>
        <item>Decompose a task that performs complex processing into a series of separate elements that can be reused. This can improve performance, scalability, and reusability by allowing task elements that perform the processing to be deployed and scaled independently.An application is required to perform a variety of tasks of varying complexity on the information that it processes. A straightforward but inflexible approach to implementing an application is to perform this processing as a monolithic module. However, this approach is likely to reduce the opportunities for refactoring the code, optimizing it, or reusing it if parts of the same processing are required elsewhere within the application.The figure illustrates the issues with processing data using the monolithic approach. An application receives and processes data from two sources. The data from each source is processed by a separate module that performs a series of tasks to transform this data, before passing the result to the business logic of the application.</item>
        <item>The broker pattern is an architectural pattern that can be used to structure distributed software systems with decoupled components that interact by remote procedure calls. A broker component is responsible for coordinating communication, such as forwarding requests, as well as for transmitting results and exceptions.Motivation using this is Usually, there is a need of having great flexibility, maintainability and changeability when developing applications. Scalability is reduced. Inherent networking complexities such as security concerns, partial failures, etc. Networking diversity in protocols, operating systems, hardware.</item>
        <item>Peer-to-peer architecture (P2P architecture) is a commonly used computer networking architecture in which each workstation, or node, has the same capabilities and responsibilities. It is often compared and contrasted to the classic client/server architecture, in which some computers are dedicated to serving others.P2P may also be used to refer to a single software program designed so that each instance of the program may act as both client and server, with the same responsibilities and status.P2P networks have many applications, but the most common is for content distribution. This includes software publication and distribution, content delivery networks, streaming media and peercasting for multicasting streams, which facilitates on-demand content delivery. Other applications involve science, networking, search and communication networks. Even the U.S. Department of Defense has started researching applications for P2P networks for modern network warfare strategies.P2P architecture is often referred to as a peer-to-peer network.</item>
        <item>The concept of MVCs was first introduced by Trygve Reenskaug, who proposed it as a way to develop desktop application GUIs. Today the MVC pattern is used for modern web applications because it allows the application to be scalable, maintainable, and easy to expand.The MVC pattern helps you break up the frontend and backend code into separate components. This way, its much easier to manage and make changes to either side without them interfering with each other.But this is easier said than done, especially when several developers need to update, modify, or debug a full-blown application simultaneously. The conclusion is The most attractive concept of the MVC pattern is separation of concerns. Modern web applications are very complex, and making a change can sometimes be a big headache.Managing the frontend and backend in smaller, separate components allows for the application to be scalable, maintainable, and easy to expand.</item>
        <item>A blackboard system is an artificial intelligence approach based on the blackboard architectural model,where a common knowledge base, the blackboard, is iteratively updated by a diverse group of specialist knowledge sources, starting with a problem specification and ending with a solution. Each knowledge source updates the blackboard with a partial solution when its internal constraints match the blackboard state. In this way, the specialists work together to solve the problem. The blackboard model was originally designed as a way to handle complex, ill-defined problems, where the solution is the sum of its parts.Blackboard-like systems have been constructed within modern Bayesian machine learning settings, using agents to add and remove Bayesian network nodes. In these Bayesian Blackboard systems, the heuristics can acquire more rigorous probabilistic meanings as proposal and acceptances in Metropolis Hastings sampling though the space of possible structures.Conversely, using these mappings, existing Metropolis-Hastings samplers over structural spaces may now thus be viewed as forms of blackboard systems even when not named as such by the authors. Such samplers are commonly found in musical transcription algorithms for example. Blackboard systems have also been used to build large-scale intelligent systems for the annotation of media content, automating parts of traditional social science research. In this domain, the problem of integrating various AI algorithms into a single intelligent system arises spontaneously, with blackboards providing a way for a collection of distributed, modular natural language processing algorithms to each annotate the data in a central space, without needing to coordinate their behavior.</item>
        <item>In computer programming, the interpreter pattern is a design pattern that specifies how to evaluate sentences in a language. The basic idea is to have a class for each symbol (terminal or nonterminal) in a specialized computer language. The syntax tree of a sentence in the language is an instance of the composite pattern and is used to evaluate (interpret) the sentence for a client. nterpreter ( English  Interpreter), also translated as a computer program , can be a high-level programming language line direct translation run. The interpreter does not translate the entire program at once, just like an intermediary, and each time the program is run, it is turned into another language to run, so the interpreters program runs slower. It runs at once with every translation of a single line of programming, then translates the next line, then runs, so it goes on. In summary The interpreter is the program used to execute other programs.</item>
    </string-array>

</resources>